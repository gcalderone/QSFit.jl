var documenterSearchIndex = {"docs":
[{"location":"components/#Components","page":"Components","title":"Components","text":"","category":"section"},{"location":"components/","page":"Components","title":"Components","text":"The QSFit.jl package implements the following GModelFit-compatible components:","category":"page"},{"location":"components/#balmercont","page":"Components","title":"balmercont","text":"","category":"section"},{"location":"components/","page":"Components","title":"Components","text":"Balmer continuum (λ < 3645Å) and pseudo-continuum (i.e. unresolved Balmer emission lines at λ < 3645Å).","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"using GModelFit, Gnuplot, QSFit\ncomp = QSFit.balmercont(1, 1)\n@gp \"set grid\" :-\n@gp :- xlab=\"Wavelength [A]\" ylab=\"Lum. density [arb.units]\" :-\n@gp :- 3645.07.*[1,1] [0, 1.1] \"w l notit dt 4 lc rgb 'black'\" :-\nx = Domain(1000.:4500)\n@gp :- coords(x) comp(x, ratio=1)   \"w l notit lw 2 lc rgb 'red'\"\n@gp :- coords(x) comp(x, ratio=0.5) \"w l notit lw 2 lc rgb 'blue'\"\nsaveas(\"balmercont\") # hide","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"(Image: )","category":"page"},{"location":"components/#cutoff_powerlaw","page":"Components","title":"cutoff_powerlaw","text":"","category":"section"},{"location":"components/","page":"Components","title":"Components","text":"Continuum cutoff-powerlaw","category":"page"},{"location":"components/#gaussconv","page":"Components","title":"gaussconv","text":"","category":"section"},{"location":"components/","page":"Components","title":"Components","text":"Convolution of a spectrum sampled on a log-regular grid with a Gaussian kernel.","category":"page"},{"location":"components/#hostgalaxy","page":"Components","title":"hostgalaxy","text":"","category":"section"},{"location":"components/","page":"Components","title":"Components","text":"Host galaxy templates","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"SWIRE templates:\nusing GModelFit, Gnuplot, QSFit\nx = Domain(3e3:1.:2e4)\n@gp xr=[3500,6700] \"set grid\" :-\nfor t in filter(x -> x[:library] == \"swire\", QSFit.list_hostgalaxy_templates())\n    local comp = QSFit.hostgalaxy(t[:template], library=t[:library])\n    @gp :- coords(x) comp(x) \"w l t '$(t[:template])'\"\nend\nsaveas(\"hostgalaxy_swire\") # hide\n(Image: )\nIlbert+09 templates:\nusing GModelFit, Gnuplot, QSFit\nx = Domain(3e3:1.:2e4)\n@gp xr=[3500,6700] \"set grid\" :-\nfor t in filter(x -> x[:library] == \"ILBERT2009\", QSFit.list_hostgalaxy_templates())\n    local comp = QSFit.hostgalaxy(t[:template], library=t[:library])\n    @gp :- coords(x) comp(x) \"w l t '$(t[:template])'\"\nend\nsaveas(\"hostgalaxy_ilbert09\") # hide\n(Image: )","category":"page"},{"location":"components/#interpolator","page":"Components","title":"interpolator","text":"","category":"section"},{"location":"components/","page":"Components","title":"Components","text":"Interpolate generic template on a wavelength grid.","category":"page"},{"location":"components/#ironopt","page":"Components","title":"ironopt","text":"","category":"section"},{"location":"components/","page":"Components","title":"Components","text":"Iron complex emission lines at optical wavelengths (from Véron-Cetty et al. 2004).","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"using GModelFit, Gnuplot, QSFit\nx = Domain(3.5e3:7e3)\n@gp \"set grid\"\ncomp = QSFit.ironopt_broad(5000.)\n@gp :- coords(x) comp(x) \"w l t '$(comp.fwhm)'\"\ncomp = QSFit.ironopt_narrow(1000.)\n@gp :- coords(x) comp(x) \"w l t '$(comp.fwhm)'\"\nsaveas(\"ironopt\") # hide","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"(Image: )","category":"page"},{"location":"components/#ironuv","page":"Components","title":"ironuv","text":"","category":"section"},{"location":"components/","page":"Components","title":"Components","text":"Iron complex emission lines at UV wavelengths (from Vestergaard & Wilkes 2001).","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"using GModelFit, Gnuplot, QSFit\nx = Domain(1e3:1:3.5e3)\ncomp = QSFit.ironuv(3000.)\n@gp \"set grid\" coords(x) comp(x) \"w l notit\"\nsaveas(\"ironuv\") # hide","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"(Image: )","category":"page"},{"location":"components/#powerlaw","page":"Components","title":"powerlaw","text":"","category":"section"},{"location":"components/","page":"Components","title":"Components","text":"Continuum powerlaw.","category":"page"},{"location":"components/#sbpl","page":"Components","title":"sbpl","text":"","category":"section"},{"location":"components/","page":"Components","title":"Components","text":"Continuum smoothly broken powerlaw.","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"using GModelFit, Gnuplot, QSFit\ncomp = QSFit.sbpl(20)\ncomp.alpha1.val =  2\ncomp.alpha2.val = -2\ncomp.delta.val = 0.5\n\nx = Domain(0.7:0.01:500)\n@gp    coords(x) comp(x, delta=0.5) \"w l notit\" xlog=true ylog=true\n@gp :- coords(x) comp(x, delta=0.3) \"w l notit\"\n@gp :- coords(x) comp(x, delta=0.1) \"w l notit\"\nsaveas(\"sbpl\") # hide","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"(Image: )","category":"page"},{"location":"components/#Emission-lines","page":"Components","title":"Emission lines","text":"","category":"section"},{"location":"components/","page":"Components","title":"Components","text":"SpecLineAsymmGauss: Emission line with asymmetric Gaussian profile;\nSpecLineGauss: Emission line with Gaussian profile;\nSpecLineLorentz: Emission line with Lorentz profile;\nSpecLineVoigt: Emission line with Voigt profile;","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"using GModelFit, Gnuplot, QSFit, Statistics\ndom = Domain(3.485e3:0.1:3.515e3)\nc1 = QSFit.SpecLineGauss(mean(coords(dom)))\nc2 = QSFit.SpecLineLorentz(mean(coords(dom)))\nc3 = QSFit.SpecLineVoigt(mean(coords(dom)))\n@gp    coords(dom) c1(dom, fwhm=300) \"w l t 'Gauss'   lw 3 \"\n@gp :- coords(dom) c2(dom, fwhm=300) \"w l t 'Lorentz' lw 3 \"\n@gp :- coords(dom) c3(dom, fwhm=300, log_a=-2) \"w l t 'Voigt-2' dt 2\"\n@gp :- coords(dom) c3(dom, fwhm=300, log_a=-1) \"w l t 'Voigt-1'\"\n@gp :- coords(dom) c3(dom, fwhm=300, log_a= 0) \"w l t 'Voigt+0'\"\n@gp :- coords(dom) c3(dom, fwhm=300, log_a= 1) \"w l t 'Voigt+1'\"\n@gp :- coords(dom) c3(dom, fwhm=300, log_a= 2) \"w l t 'Voigt+2' dt 2\"\nsaveas(\"lineprofiles\") # hide","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"(Image: )","category":"page"},{"location":"#QSFit.jl","page":"QSFit","title":"QSFit.jl","text":"","category":"section"},{"location":"","page":"QSFit","title":"QSFit","text":"QSO spectral fitting made easy !!","category":"page"},{"location":"","page":"QSFit","title":"QSFit","text":"(Image: Stars)","category":"page"},{"location":"","page":"QSFit","title":"QSFit","text":"warn: Warn\nThis software is under active development and details may change at any time without notice.  Also, documentation is not yet exhaustive.","category":"page"},{"location":"","page":"QSFit","title":"QSFit","text":"QSFit started as an attempt to perform automatic analysis of optical spectra of AGNs and QSOs in a simple, replicable and shareable way. The first implementation in IDL language (see repo here has been used to analyze 71261 AGN and QSO spectra from SDSS DR10.  The resulting spectral properties (such as emission line luminosities and widths, continuum slopes, etc.) are collected in a catalog in FITS format, as well as being publicly available here: https://qsfit.inaf.it/.","category":"page"},{"location":"","page":"QSFit","title":"QSFit","text":"The details of the spectral analysis are presented in a paper: Calderone et al. 2017 (also available on arXiv).","category":"page"},{"location":"","page":"QSFit","title":"QSFit","text":"The code has now been ported to Julia and the new package is dubbed QSFit.jl.  It comes with the following advantages with respect to the IDL version:","category":"page"},{"location":"","page":"QSFit","title":"QSFit","text":"Julia is released with a MIT license and doesn't require a paid license to be executed;\nIt provides better performances and allows to distribute workload on multiple CPUs or multiple host;\nIt provides several reusable Components and a few Recipes to perform automatic spectral analysis as well as interactive emissione line fitting;\nIt exploits the concept of customizable recipes (see Recipes) to customize the analysis for specific purposes;","category":"page"},{"location":"","page":"QSFit","title":"QSFit","text":"QSFit.jl relies on the GModelFit.jl package to perform spectral fitting.  A basic knowledge of such package is required to get the most out of QSFit.jl.","category":"page"},{"location":"#Installation","page":"QSFit","title":"Installation","text":"","category":"section"},{"location":"","page":"QSFit","title":"QSFit","text":"In the Julia REPL type:","category":"page"},{"location":"","page":"QSFit","title":"QSFit","text":"using Pkg\nPkg.add(\"GModelFit\")\nPkg.add(\"GModelFitViewer\")\nPkg.add(\"QSFit\")","category":"page"},{"location":"","page":"QSFit","title":"QSFit","text":"To test the package type Pkg.test(\"QSFit\").","category":"page"},{"location":"#Basic-usage","page":"QSFit","title":"Basic usage","text":"","category":"section"},{"location":"","page":"QSFit","title":"QSFit","text":"The most important types used in QSFit.jl are:","category":"page"},{"location":"","page":"QSFit","title":"QSFit","text":"Spectrum: it represent an observed spectrum of a AGN or QSO.  It contains both the observed wavelengths and flux densities (with associated undertainties), as well as a map of \"good\" (i.e. reliable) spectral bins and an indication of spectral resolution.  The Spectrum object can operate on spectra taken from any instrument (not only SDSS);\nCRecipe: it is a container for a specific recipe to be used to analyze a Spectrum, and for all recipe-specific options.  QSFit.jl provides a few Built-in recipes to analyze the spectrum, which can optionally be customized by the user.  New recipes can also be implemented, either extending the built-in ones or starting from scratch.","category":"page"},{"location":"","page":"QSFit","title":"QSFit","text":"The typical workflow for a spectral analysis is as follows:","category":"page"},{"location":"","page":"QSFit","title":"QSFit","text":"using QSFit, QSFit.QSORecipes\n# Download a spectrum\nfilename = download(\"http://dr10.sdss3.org/sas/dr10/sdss/spectro/redux/26/spectra/0752/spec-0752-52251-0323.fits\")\n\n# Read spectrum into a Spectrum Object\nspec = Spectrum(Val(:SDSS_DR10), filename, label=\"My SDSS source\")\n\n# Create a CRecipe object based on the Type1 recipe to analyze the spectrum\nrecipe = CRecipe{Type1}(redshift=0.3806, Av=0.21)\n\n# Analyze the spectrum with the above recipe\nres = analyze(recipe, spec)\n\n# Display best fit parameter values:\nshow(res.bestfit)","category":"page"},{"location":"","page":"QSFit","title":"QSFit","text":"The best fit model can be displayed using either Gnuplot.jl (to open a plot window):","category":"page"},{"location":"","page":"QSFit","title":"QSFit","text":"using Gnuplot\n@gp res yrange=[0, 0.25]\nsaveas(\"example1\") # hide","category":"page"},{"location":"","page":"QSFit","title":"QSFit","text":"(Image: )","category":"page"},{"location":"","page":"QSFit","title":"QSFit","text":"or GModelFitViewer.jl (to display the plot in a browser):","category":"page"},{"location":"","page":"QSFit","title":"QSFit","text":"using GModelFitViewer\nviewer(res)\nprintln() # hide","category":"page"},{"location":"","page":"QSFit","title":"QSFit","text":"Also, the best fit parameter values can be accessed for any component with (e.g.):","category":"page"},{"location":"","page":"QSFit","title":"QSFit","text":"println(\"Hb integrated luminosity: \",\n        res.bestfit[:Hb_br].norm.val, \" +/- \",\n        res.bestfit[:Hb_br].norm.unc, \" 10^42 erg s^-1\")\nprintln(\"Hb full width at half maximum: \",\n        res.bestfit[:Hb_br].fwhm.val, \" +/- \",\n        res.bestfit[:Hb_br].fwhm.unc, \" km/s\")\nprintln(\"Host galaxy lum. density at 5500A: \",\n        res.bestfit[:Galaxy].norm.val, \" +/- \",\n        res.bestfit[:Galaxy].norm.unc, \" 10^42 erg s^-1 A^-1\")","category":"page"},{"location":"recipes/#Recipes","page":"Recipes","title":"Recipes","text":"","category":"section"},{"location":"recipes/#Introduction","page":"Recipes","title":"Introduction","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"The essential steps to analyze a QSO spectrum typically involve the identification of relevant features (such as emission lines, continuum emission, host galaxy emission, etc.) and their association with a corresponding component in a model[1] to fit the empirical data.  The resulting best fit parameter values (and associated uncertainties) will allow further analysis.","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"[1]: Note: the terms component and model used here have the same meaning as in the GmodelFit.jl documentation.","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"While the above steps are always the same, the finer details of the analysis depend on several aspects such as the spectrograph being used, its spectral resolution, the wavelength coverage, the target redshift, the peculiar features in the spectrum, the accuracy required in the outcomes, etc.","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"To address such complexity QSFit.jl provides a few built-in analysis recipes, namely a sequence of steps aimed to build a spectral model, and to fit it against an empirical 1D spectrum.  Each recipe comes with a number of pre-defined options which can easily be customized to address specific cases.  E.g., to check default options for the Type1 recipe:","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"using QSFit, QSFit.QSORecipes\nrecipe = CRecipe{Type1}()","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"You can modify any option with (e.g.):","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"recipe.use_host_template = false","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"In case the customization via options is not enought, it is possible to Define new recipes by extending the built-in ones.","category":"page"},{"location":"recipes/#Built-in-recipes","page":"Recipes","title":"Built-in recipes","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"The built-in recipes are defined in the QSFit.LineFitRecipes and QSFit.QSORecipes submodules.","category":"page"},{"location":"recipes/#InteractiveLineFit","page":"Recipes","title":"InteractiveLineFit","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"Interactive emission line fitting. The user is asked to provide the initial guess wavelengths of emission lines by clicking on a plot (provided by the Gnuplot.jl package), as well as to decide the line profile to be used. Example:","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"using QSFit, QSFit.LineFitRecipes\n\nfilename = download(\"http://dr10.sdss3.org/sas/dr10/sdss/spectro/redux/26/spectra/0752/spec-0752-52251-0323.fits\")\nspec = Spectrum(Val(:SDSS_DR10), filename)\nrecipe = CRecipe{InteractiveLineFit}(redshift=0.3806)\nres = analyze(recipe, spec)","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"After interactive selection the above code will print the relevant options to replicate the same analysis using the LineFit recipe (see below);","category":"page"},{"location":"recipes/#LineFit","page":"Recipes","title":"LineFit","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"Non-interactive line fitting.  The user should provide the relevant options such as the redshift, the wavelength range, the guess wavelengths of the emission lines, etc.  The latter can be obtained using the above mentioned InteractiveLineFit recipe.","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"Example:","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"using QSFit, QSFit.LineFitRecipes\n\nfilename = download(\"http://dr10.sdss3.org/sas/dr10/sdss/spectro/redux/26/spectra/0752/spec-0752-52251-0323.fits\")\nspec = Spectrum(Val(:SDSS_DR10), filename)\nrecipe = CRecipe{LineFit}(redshift=0.3806)\nrecipe.wavelength_range = [4530.90809628009, 5392.50547045952]\nrecipe.lines = QSFit.SpecLineSet()\nQSFit.add_line!(recipe, recipe.lines, 4864.77, NarrowLine, BroadLine)\nQSFit.add_line!(recipe, recipe.lines, 5010.88, ForbiddenLine)\nres = analyze(recipe, spec)","category":"page"},{"location":"recipes/#Type1","page":"Recipes","title":"Type1","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"Automatic spectral analysis of Type1 AGN and QSO at redshifts <~ 2.1. ","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"Example:","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"using QSFit, QSFit.QSORecipes\nfilename = download(\"http://dr10.sdss3.org/sas/dr10/sdss/spectro/redux/26/spectra/0752/spec-0752-52251-0323.fits\")\nspec = Spectrum(Val(:SDSS_DR10), filename)\nrecipe = CRecipe{Type1}(redshift=0.3806, Av=0.21)\nres = analyze(recipe, spec)","category":"page"},{"location":"recipes/#Define-new-recipes","page":"Recipes","title":"Define new recipes","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"As anticipated, recipes are essentially a sequence of steps to carry out the spectral analysis.  They are implemented adopting a pattern which allows to easily define new recipes by inheriting the functionalities of the existiung ones, and overriding only the specific steps which needs to be customized or improved.","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"From the implementation point of view a recipe is an abstract type inheriting from AbstractRecipe, and the steps are functions accepting that type as an argument.  Consider the following example where we define a recipe A, a few steps and substeps, as well as a main analyze function triggering execution of steps in the proper order:","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"abstract type A <: AbstractRecipe end\n\nstep1(t::Type{T}) where T <: A = println(\"Invoked step1 from recipe A\")\n\nsubstep2a(::Type{T}) where T <: A = println(\"  Invoked substep2a from recipe A\")\nsubstep2b(::Type{T}) where T <: A = println(\"  Invoked substep2b from recipe A\")\n\nfunction step2(::Type{T}) where T <: A\n    println(\"Invoked step2 from recipe A\")\n    substep2a(T)\n    substep2b(T)\nend\n\nfunction analyze(t::Type{T}) where T <: A\n    println(\"Invoked analyze from recipe A\")\n    step1(t)\n    step2(t)\nend\n\nanalyze(A)","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"Suppose we want to reimplement step1, and to reuse substep2b by performing some extra operation after it has been executed.  We'll need to define a new recipe B inheriting from A, and implement new methods for the step1 and substep2b functions:","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"abstract type B <: A end\n\nstep1(t::Type{T}) where T <: B = println(\"Invoked step1 from recipe B\")\n\nfunction substep2b(t::Type{T}) where T <: B\n    @invoke substep2b(t::Type{<: supertype(T)})\n    println(\"  Additional operation performed in substep2b from recipe B\")\nend\n\nanalyze(B)","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"The above pattern allows to maximize code reuse (i.e., avoid reinventing the wheel), as well as avoiding conditional branches (if-then-else) since the identification of the steps to be executed is performed via multiple dispatch.","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"The actual recipes code follows the above pattern except for two details:","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"we use the CRecipe{} type in place of ::Type{} since the latter is just an abstract type and can not contain any data, while the fomer is a concrete one and can store the recipe options;\nby convention, each recipe step should invoke the @track_recipe macro as first statement.  This way it is possible to track down which method is actually being executed (this requires invoking QSFit.track_recipe(true));","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"In the following example we will define a new recipe named MyRecipe inheriting from Type1 and","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"replace the power law continuum component with a smoothly broken power law;\nsmooth the host galaxy template with a 50 points boxcar average;","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"using GModelFit, QSFit, QSFit.QSORecipes, Statistics\n\nabstract type MyRecipe <: Type1 end\n\nimport QSFit.QSORecipes: getdomain, getmodel, getdata\nimport QSFit.QSORecipes.add_qso_continuum!\nfunction add_qso_continuum!(recipe::CRecipe{T}, fp::GModelFit.FitProblem, ith::Int) where T <: MyRecipe\n    @track_recipe\n    λ = coords(getdomain(fp, ith))\n\n    comp = QSFit.sbpl(3000)\n    comp.x0.val = median(λ)\n    comp.norm.val = median(values(getdata(fp, ith)))\n    comp.norm.low = comp.norm.val / 1000.  # ensure contiuum remains positive (needed to estimate EWs)\n    comp.delta.val = 0.001\n    comp.delta.fixed = true\n\tgetmodel(fp, ith)[:QSOcont] = comp\n    push!(getmodel(fp, ith)[:Continuum].list, :QSOcont)\nend\n\nimport QSFit.QSORecipes.add_host_galaxy!\nfunction add_host_galaxy!(recipe::CRecipe{T}, fp::GModelFit.FitProblem, ith::Int) where T <: MyRecipe\n    @track_recipe\n    @invoke add_host_galaxy!(recipe::CRecipe{<: Type1}, fp, ith)\n\tmodel = getmodel(fp, ith)\n    t = model[:Galaxy].template\n    n = 50\n\tmodel[:Galaxy].template[1+n:length(t)-n] .= [mean(t[i-n:i+n]) for i in 1+n:length(t)-n]\nend\n\nQSFit.track_recipe(true)\nfilename = download(\"http://dr10.sdss3.org/sas/dr10/sdss/spectro/redux/26/spectra/0752/spec-0752-52251-0323.fits\")\nspec = Spectrum(Val(:SDSS_DR10), filename)\nrecipe = CRecipe{MyRecipe}(redshift=0.3806, Av=0.21)\nres = analyze(recipe, spec)\ndisplay(res.bestfit)","category":"page"}]
}
