var documenterSearchIndex = {"docs":
[{"location":"components/#Components","page":"Components","title":"Components","text":"The QSFit.jl package implements the following GModelFit-compatible components:","category":"section"},{"location":"components/#balmercont","page":"Components","title":"balmercont","text":"Balmer continuum (λ < 3645Å) and pseudo-continuum (i.e. unresolved Balmer emission lines at λ < 3645Å).\n\nusing GModelFit, Gnuplot, QSFit\ncomp = QSFit.balmercont(1, 1)\n@gp \"set grid\" :-\n@gp :- xlab=\"Wavelength [A]\" ylab=\"Lum. density [arb.units]\" :-\n@gp :- 3645.07.*[1,1] [0, 1.1] \"w l notit dt 4 lc rgb 'black'\" :-\nx = Domain(1000.:4500)\n@gp :- coords(x) comp(x, ratio=1)   \"w l notit lw 2 lc rgb 'red'\"\n@gp :- coords(x) comp(x, ratio=0.5) \"w l notit lw 2 lc rgb 'blue'\"\nsaveas(\"balmercont\") # hide\n\n(Image: )","category":"section"},{"location":"components/#cutoff_powerlaw","page":"Components","title":"cutoff_powerlaw","text":"Continuum cutoff-powerlaw","category":"section"},{"location":"components/#gaussconv","page":"Components","title":"gaussconv","text":"Convolution of a spectrum sampled on a log-regular grid with a Gaussian kernel.","category":"section"},{"location":"components/#hostgalaxy","page":"Components","title":"hostgalaxy","text":"Host galaxy templates\n\nSWIRE templates:\nusing GModelFit, Gnuplot, QSFit\nx = Domain(3e3:1.:2e4)\n@gp xr=[3500,6700] \"set grid\" :-\nfor t in filter(x -> x[:library] == \"swire\", QSFit.list_hostgalaxy_templates())\n    local comp = QSFit.hostgalaxy(t[:template], library=t[:library])\n    @gp :- coords(x) comp(x) \"w l t '$(t[:template])'\"\nend\nsaveas(\"hostgalaxy_swire\") # hide\n(Image: )\nIlbert+09 templates:\nusing GModelFit, Gnuplot, QSFit\nx = Domain(3e3:1.:2e4)\n@gp xr=[3500,6700] \"set grid\" :-\nfor t in filter(x -> x[:library] == \"ILBERT2009\", QSFit.list_hostgalaxy_templates())\n    local comp = QSFit.hostgalaxy(t[:template], library=t[:library])\n    @gp :- coords(x) comp(x) \"w l t '$(t[:template])'\"\nend\nsaveas(\"hostgalaxy_ilbert09\") # hide\n(Image: )","category":"section"},{"location":"components/#interpolator","page":"Components","title":"interpolator","text":"Interpolate generic template on a wavelength grid.","category":"section"},{"location":"components/#ironopt","page":"Components","title":"ironopt","text":"Iron complex emission lines at optical wavelengths (from Véron-Cetty et al. 2004).\n\nusing GModelFit, Gnuplot, QSFit\nx = Domain(3.5e3:7e3)\n@gp \"set grid\"\ncomp = QSFit.ironopt_broad(5000.)\n@gp :- coords(x) comp(x) \"w l t '$(comp.fwhm)'\"\ncomp = QSFit.ironopt_narrow(1000.)\n@gp :- coords(x) comp(x) \"w l t '$(comp.fwhm)'\"\nsaveas(\"ironopt\") # hide\n\n(Image: )","category":"section"},{"location":"components/#ironuv","page":"Components","title":"ironuv","text":"Iron complex emission lines at UV wavelengths (from Vestergaard & Wilkes 2001).\n\nusing GModelFit, Gnuplot, QSFit\nx = Domain(1e3:1:3.5e3)\ncomp = QSFit.ironuv(3000.)\n@gp \"set grid\" coords(x) comp(x) \"w l notit\"\nsaveas(\"ironuv\") # hide\n\n(Image: )","category":"section"},{"location":"components/#powerlaw","page":"Components","title":"powerlaw","text":"Continuum powerlaw.","category":"section"},{"location":"components/#sbpl","page":"Components","title":"sbpl","text":"Continuum smoothly broken powerlaw.\n\nusing GModelFit, Gnuplot, QSFit\ncomp = QSFit.sbpl(20)\ncomp.alpha1.val =  2\ncomp.alpha2.val = -2\ncomp.delta.val = 0.5\n\nx = Domain(0.7:0.01:500)\n@gp    coords(x) comp(x, delta=0.5) \"w l notit\" xlog=true ylog=true\n@gp :- coords(x) comp(x, delta=0.3) \"w l notit\"\n@gp :- coords(x) comp(x, delta=0.1) \"w l notit\"\nsaveas(\"sbpl\") # hide\n\n(Image: )","category":"section"},{"location":"components/#Emission-lines","page":"Components","title":"Emission lines","text":"SpecLineAsymmGauss: Emission line with asymmetric Gaussian profile;\nSpecLineGauss: Emission line with Gaussian profile;\nSpecLineLorentz: Emission line with Lorentz profile;\nSpecLineVoigt: Emission line with Voigt profile;\n\nusing GModelFit, Gnuplot, QSFit, Statistics\ndom = Domain(3.485e3:0.1:3.515e3)\nc1 = QSFit.SpecLineGauss(mean(coords(dom)))\nc2 = QSFit.SpecLineLorentz(mean(coords(dom)))\nc3 = QSFit.SpecLineVoigt(mean(coords(dom)))\n@gp    coords(dom) c1(dom, fwhm=300) \"w l t 'Gauss'   lw 3 \"\n@gp :- coords(dom) c2(dom, fwhm=300) \"w l t 'Lorentz' lw 3 \"\n@gp :- coords(dom) c3(dom, fwhm=300, log_a=-2) \"w l t 'Voigt-2' dt 2\"\n@gp :- coords(dom) c3(dom, fwhm=300, log_a=-1) \"w l t 'Voigt-1'\"\n@gp :- coords(dom) c3(dom, fwhm=300, log_a= 0) \"w l t 'Voigt+0'\"\n@gp :- coords(dom) c3(dom, fwhm=300, log_a= 1) \"w l t 'Voigt+1'\"\n@gp :- coords(dom) c3(dom, fwhm=300, log_a= 2) \"w l t 'Voigt+2' dt 2\"\nsaveas(\"lineprofiles\") # hide\n\n(Image: )","category":"section"},{"location":"python/#Use-with-Python","page":"Use with Python","title":"Use with Python","text":"QSFit can also be invoked from Python using JuliaCall as a bridge between the two languages.  The procedure is as follows:\n\nInstall Julia as usual;\nInstall QSFit;\nInstall the JuliaCall Python package with: pip install juliacall;\nStart Python specifying the path to the Julia installation bin directory, e.g. python -X juliacall-home=/usr/local/julia-1.12.4/bin.\n\nThe simple example presented here can then be executed from Python as follows:\n\nfrom juliacall import Main as jl\nimport numpy as np\nimport matplotlib.pyplot as plt\n\njl.seval('using QSFit, QSFit.QSORecipes, TypedJSON, GModelFit, GModelFitViewer')\nfilename = str(jl.seval('download(\"http://dr10.sdss3.org/sas/dr10/sdss/spectro/redux/26/spectra/0752/spec-0752-52251-0323.fits\")'))\njl.seval('spec = Spectrum(Val(:SDSS_DR10), \"{}\", label=\"0752-52251-0323, z=0.38\")'.format(filename))\njl.seval('recipe = CRecipe{Type1}(redshift=0.3806, Av=0.21)')\njl.seval('res = analyze(recipe, spec)')\njl.seval('TypedJSON.serialize(\"{}.json\", res)'.format(filename))\njl.seval('viewer(res)')\n\nprint('Fit statistic: ', float(jl.seval('res.fsumm.fitstat')))\nprint('Hb integrated luminosity: ', float(jl.seval('res.bestfit[:Hb_br].norm.val')), ' +/- ', float(jl.seval('res.bestfit[:Hb_br].norm.unc')), ' 10^42 erg s^-1')\nprint('Hb full width at half maximum: ', float(jl.seval('res.bestfit[:Hb_br].fwhm.val')), ' +/- ', float(jl.seval('res.bestfit[:Hb_br].fwhm.unc')), ' km/s')\nprint('Host galaxy lum. density at 5500A: ', float(jl.seval('res.bestfit[:Galaxy].norm.val')), ' +/- ', float(jl.seval('res.bestfit[:Galaxy].norm.unc')), ' 10^42 erg s^-1 A^-1')\n\n# Plot using matplotlib\nx = np.asarray(jl.seval('coords(domain(res.data))'))\ny = np.asarray(jl.seval('values(res.data)'))\ne = np.asarray(jl.seval('uncerts(res.data)'))\nxm = np.asarray(jl.seval('coords(domain(res.bestfit))'))\nym = np.asarray(jl.seval('res.bestfit()'))\n\nplt.title(str(jl.seval('res.spec[:label]')))\nplt.xlabel('Rest frame wavelength [A]')\nplt.ylabel('Lum. density [10^42 erg/s/A')\nplt.errorbar(x, y, yerr=e, fmt='o', label='Data')\nplt.plot(xm, ym, 'r', label='Model', zorder=10)\nplt.legend(loc='upper right')\nplt.show()\n\nThe following plot will appear on the screen: (Image: )","category":"section"},{"location":"#QSFit.jl","page":"QSFit","title":"QSFit.jl","text":"QSO spectral fitting made easy !!\n\n(Image: Stars)\n\nQSFit started as an attempt to perform automatic analysis of optical spectra of AGNs and QSOs in a simple, replicable and shareable way. The first implementation in IDL language (see repo here has been used to analyze 71261 AGN and QSO spectra from SDSS DR10.  The resulting spectral properties (such as emission line luminosities and widths, continuum slopes, etc.) are collected in a catalog in FITS format, as well as being publicly available here: https://qsfit.inaf.it/.\n\nThe details of the spectral analysis are presented in a paper: Calderone et al. 2017 (also available on arXiv).\n\nThe code has now been ported to Julia and the new package is dubbed QSFit.jl.  It comes with the following advantages with respect to the IDL version:\n\nJulia is released with a MIT license and doesn't require a paid license to be executed;\nIt provides better performances and allows to distribute workload on multiple CPUs or multiple host;\nIt provides several reusable Components and a few Recipes to perform automatic spectral analysis as well as interactive emissione line fitting;\nIt exploits the concept of customizable recipes (see Recipes) to customize the analysis for specific purposes;\n\nQSFit.jl relies on the GModelFit.jl package to perform spectral fitting.  A basic knowledge of such package is required to get the most out of QSFit.jl.","category":"section"},{"location":"#Installation","page":"QSFit","title":"Installation","text":"In the Julia REPL type:\n\nusing Pkg\nPkg.add(\"GModelFit\")\nPkg.add(\"GModelFitViewer\")\nPkg.add(\"QSFit\")\n\nTo test the package type Pkg.test(\"QSFit\").","category":"section"},{"location":"#Basic-usage","page":"QSFit","title":"Basic usage","text":"The most important types used in QSFit.jl are:\n\nSpectrum: it represent an observed spectrum of a AGN or QSO.  It contains both the observed wavelengths and flux densities (with associated undertainties), as well as a map of \"good\" (i.e. reliable) spectral bins and an indication of spectral resolution.  The Spectrum object can operate on spectra taken from any instrument (not only SDSS);\nCRecipe: it is a container for a specific recipe to be used to analyze a Spectrum, and for all recipe-specific options.  QSFit.jl provides a few Built-in recipes to analyze the spectrum, which can optionally be customized by the user.  New recipes can also be implemented, either extending the built-in ones or starting from scratch.\n\nThe typical workflow for a spectral analysis is as follows:\n\nusing QSFit, QSFit.QSORecipes\n# Download a spectrum\nfilename = download(\"http://dr10.sdss3.org/sas/dr10/sdss/spectro/redux/26/spectra/0752/spec-0752-52251-0323.fits\")\n\n# Read spectrum into a Spectrum Object\nspec = Spectrum(Val(:SDSS_DR10), filename, label=\"My SDSS source\")\n\n# Create a CRecipe object based on the Type1 recipe to analyze the spectrum\nrecipe = CRecipe{Type1}(redshift=0.3806, Av=0.21)\n\n# Analyze the spectrum with the above recipe\nres = analyze(recipe, spec)\n\n# Display best fit parameter values:\nshow(res.bestfit)\n\nThe best fit model can be displayed using either Gnuplot.jl (to open a plot window):\n\nusing Gnuplot\n@gp res yrange=[0, 0.25]\nsaveas(\"example1\") # hide\n\n(Image: )\n\nor GModelFitViewer.jl (to display the plot in a browser):\n\nusing GModelFitViewer\nviewer(res)\nprintln() # hide\n\nAlso, the best fit parameter values can be accessed for any component with (e.g.):\n\nprintln(\"Fit statistic: \", res.fsumm.fitstat)\nprintln(\"Hb integrated luminosity: \",\n        res.bestfit[:Hb_br].norm.val, \" +/- \",\n        res.bestfit[:Hb_br].norm.unc, \" 10^42 erg s^-1\")\nprintln(\"Hb full width at half maximum: \",\n        res.bestfit[:Hb_br].fwhm.val, \" +/- \",\n        res.bestfit[:Hb_br].fwhm.unc, \" km/s\")\nprintln(\"Host galaxy lum. density at 5500A: \",\n        res.bestfit[:Galaxy].norm.val, \" +/- \",\n        res.bestfit[:Galaxy].norm.unc, \" 10^42 erg s^-1 A^-1\")","category":"section"},{"location":"recipes/#Recipes","page":"Recipes","title":"Recipes","text":"","category":"section"},{"location":"recipes/#Introduction","page":"Recipes","title":"Introduction","text":"The essential steps to analyze a QSO spectrum typically involve the identification of relevant features (such as emission lines, continuum emission, host galaxy emission, etc.) and their association with a corresponding component in a model[1] to fit the empirical data.  The resulting best fit parameter values (and associated uncertainties) will allow further analysis.\n\n[1]: Note: the terms component and model used here have the same meaning as in the GmodelFit.jl documentation.\n\nWhile the above steps are always the same, the finer details of the analysis depend on several aspects such as the spectrograph being used, its spectral resolution, the wavelength coverage, the target redshift, the peculiar features in the spectrum, the accuracy required in the outcomes, etc.\n\nTo address such complexity QSFit.jl provides a few built-in analysis recipes, namely a sequence of steps aimed to build a spectral model, and to fit it against an empirical 1D spectrum.  Each recipe comes with a number of pre-defined options which can easily be customized to address specific cases.  E.g., to check default options for the Type1 recipe:\n\nusing QSFit, QSFit.QSORecipes\nrecipe = CRecipe{Type1}()\n\nYou can modify any option with (e.g.):\n\nrecipe.use_host_template = false\n\nIn case the customization via options is not enought, it is possible to Define new recipes by extending the built-in ones.","category":"section"},{"location":"recipes/#Built-in-recipes","page":"Recipes","title":"Built-in recipes","text":"The built-in recipes are defined in the QSFit.LineFitRecipes and QSFit.QSORecipes submodules.","category":"section"},{"location":"recipes/#InteractiveLineFit","page":"Recipes","title":"InteractiveLineFit","text":"Interactive emission line fitting. The user is asked to provide the initial guess wavelengths of emission lines by clicking on a plot (provided by the Gnuplot.jl package), as well as to decide the line profile to be used. Example:\n\nusing QSFit, QSFit.LineFitRecipes\n\nfilename = download(\"http://dr10.sdss3.org/sas/dr10/sdss/spectro/redux/26/spectra/0752/spec-0752-52251-0323.fits\")\nspec = Spectrum(Val(:SDSS_DR10), filename)\nrecipe = CRecipe{InteractiveLineFit}(redshift=0.3806)\nres = analyze(recipe, spec)\n\nAfter interactive selection the above code will print the relevant options to replicate the same analysis using the LineFit recipe (see below);","category":"section"},{"location":"recipes/#LineFit","page":"Recipes","title":"LineFit","text":"Non-interactive line fitting.  The user should provide the relevant options such as the redshift, the wavelength range, the guess wavelengths of the emission lines, etc.  The latter can be obtained using the above mentioned InteractiveLineFit recipe.\n\nExample:\n\nusing QSFit, QSFit.LineFitRecipes\n\nfilename = download(\"http://dr10.sdss3.org/sas/dr10/sdss/spectro/redux/26/spectra/0752/spec-0752-52251-0323.fits\")\nspec = Spectrum(Val(:SDSS_DR10), filename)\nrecipe = CRecipe{LineFit}(redshift=0.3806)\nrecipe.wavelength_range = [4530.90809628009, 5392.50547045952]\nrecipe.lines = QSFit.SpecLineSet()\nQSFit.add_line!(recipe, recipe.lines, 4864.77, NarrowLine, BroadLine)\nQSFit.add_line!(recipe, recipe.lines, 5010.88, ForbiddenLine)\nres = analyze(recipe, spec)","category":"section"},{"location":"recipes/#Type1","page":"Recipes","title":"Type1","text":"Automatic spectral analysis of Type1 AGN and QSO at redshifts <~ 2.1. \n\nExample:\n\nusing QSFit, QSFit.QSORecipes\nfilename = download(\"http://dr10.sdss3.org/sas/dr10/sdss/spectro/redux/26/spectra/0752/spec-0752-52251-0323.fits\")\nspec = Spectrum(Val(:SDSS_DR10), filename)\nrecipe = CRecipe{Type1}(redshift=0.3806, Av=0.21)\nres = analyze(recipe, spec)","category":"section"},{"location":"recipes/#Define-new-recipes","page":"Recipes","title":"Define new recipes","text":"As anticipated, recipes are essentially a sequence of steps to carry out the spectral analysis.  They are implemented adopting a pattern which allows to easily define new recipes by inheriting the functionalities of the existiung ones, and overriding only the specific steps which needs to be customized or improved.\n\nFrom the implementation point of view a recipe is an abstract type inheriting from AbstractRecipe, and the steps are functions accepting that type as an argument.  Consider the following example where we define a recipe A, a few steps and substeps, as well as a main analyze function triggering execution of steps in the proper order:\n\nabstract type A <: AbstractRecipe end\n\nstep1(t::Type{T}) where T <: A = println(\"Invoked step1 from recipe A\")\n\nsubstep2a(::Type{T}) where T <: A = println(\"  Invoked substep2a from recipe A\")\nsubstep2b(::Type{T}) where T <: A = println(\"  Invoked substep2b from recipe A\")\n\nfunction step2(::Type{T}) where T <: A\n    println(\"Invoked step2 from recipe A\")\n    substep2a(T)\n    substep2b(T)\nend\n\nfunction analyze(t::Type{T}) where T <: A\n    println(\"Invoked analyze from recipe A\")\n    step1(t)\n    step2(t)\nend\n\nanalyze(A)\n\nSuppose we want to reimplement step1, and to reuse substep2b by performing some extra operation after it has been executed.  We'll need to define a new recipe B inheriting from A, and implement new methods for the step1 and substep2b functions:\n\nabstract type B <: A end\n\nstep1(t::Type{T}) where T <: B = println(\"Invoked step1 from recipe B\")\n\nfunction substep2b(t::Type{T}) where T <: B\n    @invoke substep2b(t::Type{<: supertype(T)})\n    println(\"  Additional operation performed in substep2b from recipe B\")\nend\n\nanalyze(B)\n\nThe above pattern allows to maximize code reuse (i.e., avoid reinventing the wheel), as well as avoiding conditional branches (if-then-else) since the identification of the steps to be executed is performed via multiple dispatch.\n\nThe actual recipes code follows the above pattern except for two details:\n\nwe use the CRecipe{} type in place of ::Type{} since the latter is just an abstract type and can not contain any data, while the fomer is a concrete one and can store the recipe options;\nby convention, each recipe step should invoke the @track_recipe macro as first statement.  This way it is possible to track down which method is actually being executed (this requires invoking QSFit.track_recipe(true));\n\nIn the following example we will define a new recipe named MyRecipe inheriting from Type1 and\n\nreplace the power law continuum component with a smoothly broken power law;\nsmooth the host galaxy template with a 50 points boxcar average;\n\nusing GModelFit, QSFit, QSFit.QSORecipes, Statistics\n\nabstract type MyRecipe <: Type1 end\n\nimport QSFit.QSORecipes: getdomain, getmodel, getdata\nimport QSFit.QSORecipes.add_qso_continuum!\nfunction add_qso_continuum!(recipe::CRecipe{T}, fp::GModelFit.FitProblem, ith::Int) where T <: MyRecipe\n    @track_recipe\n    λ = coords(getdomain(fp, ith))\n\n    comp = QSFit.sbpl(3000)\n    comp.x0.val = median(λ)\n    comp.norm.val = median(values(getdata(fp, ith)))\n    comp.norm.low = comp.norm.val / 1000.  # ensure contiuum remains positive (needed to estimate EWs)\n    comp.delta.val = 0.001\n    comp.delta.fixed = true\n\tgetmodel(fp, ith)[:QSOcont] = comp\n    push!(getmodel(fp, ith)[:Continuum].list, :QSOcont)\nend\n\nimport QSFit.QSORecipes.add_host_galaxy!\nfunction add_host_galaxy!(recipe::CRecipe{T}, fp::GModelFit.FitProblem, ith::Int) where T <: MyRecipe\n    @track_recipe\n    @invoke add_host_galaxy!(recipe::CRecipe{<: Type1}, fp, ith)\n\tmodel = getmodel(fp, ith)\n    t = model[:Galaxy].template\n    n = 50\n\tmodel[:Galaxy].template[1+n:length(t)-n] .= [mean(t[i-n:i+n]) for i in 1+n:length(t)-n]\nend\n\nQSFit.track_recipe(true)\nfilename = download(\"http://dr10.sdss3.org/sas/dr10/sdss/spectro/redux/26/spectra/0752/spec-0752-52251-0323.fits\")\nspec = Spectrum(Val(:SDSS_DR10), filename)\nrecipe = CRecipe{MyRecipe}(redshift=0.3806, Av=0.21)\nres = analyze(recipe, spec)\ndisplay(res.bestfit)","category":"section"}]
}
